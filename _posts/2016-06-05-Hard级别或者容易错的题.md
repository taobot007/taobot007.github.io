---
layout: post
title: Hard级别或者容易错的题
date: 2016-06-05
tag: Leetcode
---

* 1 Parenthesis Combination
  > Implement an algorithm to print all valid (properly opened and closed) combinations of n pairs of parentheses.
  >
  > EXAMPLE
  >
  > Input: 3
  >
  > Output: ((())), (()()), ()()(), ()(()), (())()

  解法: 从f(n-1)到f(n), 我本来以为只要在左边加"()",在右边加"()",及在两边加"()"就可以了,但是实际上是有没有cover的case的,例如"(())(())",它没法通过f(3)达到.那么解法是什么呢?是建立两个count,一个是left,一个是right,初始值都是n.采用dfs,如果left>=right,放入left, left--;如果left<right,可以放入left或right.

  还有一种解法是,对f(n-1)的左边加"()",并在f(n-1)的所有的左括号后边试图加上"()".这是可以的.


* 2 Sort Big File:
  > A file is 20GB with one string per line. How to sort the file?

  解法: 这题明显不能完全依赖于memory sort,所有我们要引入disk storage.解决方案就是把file分成一个个chunk,然后依次sort后放入disk中,再把这些file两两合并,知道最终只剩下一个file.这和merge sort有点类似.这种方法叫做external sort.

* 3 Missing Int:
  > Given an input file with four billion non-negative integers, provide an algorithm to generate an integer that is not contained in the file. Assume you have 1 GB of memory available for this task.
  >
  > FOLLOW UP
  >
  > What if you have only 10MB of memory? Assume that all the values are distinct and we now have no more than one billion non-negative integers.

  解法:这里介绍bit vector的方法,对与1GB内存,其含有 8 * 1G = 8 billion bit,每个bit代表一个正整数,则内存可以放下 4 billion个正整数.然后我们遍历这个file,并mark这个bit vector,就可以知道哪个少了.

  如果我们的内存只有10M呢?我们就得把 4 billion分成1000组,然后第0组是0到4billion/100000=40K的数字的个数,第二组是40K+1到80K的数字的个数...这些统计数字只需要占用3MB内存,然后我们看哪个range少了,然后再按照bit vector的方式找就好了.

* 4 Word Rectangle:
  > 给一个含有word的list,然后从这list中找出若干个单词,组成一个矩形.矩形的每一行都是list中的单词,每一列也是list中的单词.问这个rectangle最大可能的面积.

  这题的brute force解法是从最长的words开始,作为列数,再以word的长度作为行数,然后不停地试word的组合,如果能达到特定的行数,则返回;如果达不到,则减少行数再试.如果最终只剩一行了,则减少列数,继续试.

  优化的做法是,在组成rectangle之前就已经使用Trie树决定这一行能不能放下去,如果有可能能,则放;如果不可能,就不放了.
  其实优化程度有限.这个Trie树由指定长度为rectangle的行数和列数组成.

* 5 L410 Split Array Largest Sum
  > Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.

  Solution: This is a typical DP problem. dp[n][m] could be built on top of dp[k][m - 1].
  The transaction functions is: dp[n][m] = min(max(dp[n-k][m-1], sum(nums[n-k+1:]))).

  还有更好的解法: 使用binary search,先找到bottom bounder and up bounder. 然后binary search,看如果按照这么样划分的话划出来的array的个数是大于m还是小于m.如果小于等于m的话,降低一下bar,如果大于m的话,提高一下bar,

  还有一题类似的,问传送带上的货物重量为weight[i],问船每天的load至少多少才能保证货物能再D天内load完.

* 6 L795: Number of Subarrays with Bounded Maximum
  > We are given an array A of positive integers, and two positive integers L and R (L <= R). Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least L and at most R.

  Solution: General idea: find the number A of subarrays that max is less than the upper bound, and then find the number B of subarrays that max is less than the lower bound, answer is A - B. How to find A or B? Use DP. dp_A[i] means the number of arrays that end with num[i] that max is lower than upper bound.

* 7 L786: Kth smallest prime fraction
  > A sorted list A contains 1, plus some number of primes.  Then, for every p < q in the list, we consider the fraction p/q. What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.

  Solution: create a N * N matrix. Each element is the fraction between two numbers. If the array is sorted, then we can see the features of the matrix. From right to left is increasing, from top to down is increasing. We can take use of the heapsort algorithm. Starting from the top right corner, keep putting numbers into heap and pop the smallest ones. Get k outputs.

  算法是典型的kth element in a matrix算法.

* 8 sliding window median / sliding window maximum

  这类题,总是在输入的arr外再建立另外一个array.这个新的array可以是stack,是k大小的array,递增或者递减之类的.

* 9 L1000 Minimum Cost to Merge Stones
  > There are N piles of stones arranged in a row.  The i-th pile has stones[i] stones.
  A move consists of merging exactly K consecutive piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.
  Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return -1.

  我的想法是穷尽所有组合的可能性,但是这样做太耗时.别人的方法是dp, dp[i][j][k]指的是搬动从i到j堆的石头成k堆最小要多少cost.
  Init: dp[i][j][k] = 0 if i==j and k == 1 else inf
  ans: dp[0][n-1][1]
  transition:
  1. dp[i][j][k] = min{dp[i][m][1] + dp[m+1][j][k-1]} for all i <= m < j
  2. dp[i][j][1] = dp[i][j][K] + sum(A[i]~A[j])

  Time complexity: O(n^3)
  Space complexity: O(n^2*K)

* 10 L960 Delete Columns to Make Sorted III
  > 一组string array, 长度一致,可以从选择同时去除某几位的letter,使得所有string都是单调递增.问最少去除几位?

  dp[i] := max length of increasing sub-sequence (of all strings) ends with i-th letter.
  dp[i] = max(dp[j] + 1) if all A[*][j] <= A[*][i], j < i
  Time complexity: (n*L^2)
  Space complexity: O(L)

* 11 960 Tallest Billboard
  > You are installing a billboard and want it to have the largest height.  The billboard will have two steel supports, one on each side.  Each steel support must be an equal height.You have a collection of rods which can be welded together.  For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.Return the largest possible height of your billboard installation.  If you cannot support the billboard, return 0.

  这题很难.

  我们用 dp[i][j] 来表示使用前i个柱子，高度差为j的情况下最大的公共高度h1是多少。

  状态转移:

  dp[i][j] = max(dp[i][j], dp[i – 1][j])

  dp[i][j+h] = max(dp[i][j + h], dp[i – 1][j])

  dp[i][|j-h|] = max(dp[i][|j-h|], dp[i – 1][j] + min(j, h))

* 12 L891 Super Egg Drop
  > K 个鸡蛋, M层楼,要扔多少次

  1) 如果 log(M + 1) <= K 的话,我们直接二分法,要扔log(M+1)次就好了; 2) DP方法, dp[i][j] 表示j楼i个鸡蛋要扔多少次. 那么 dp[i][j] 与 d[i-1][]的关系是什么呢?之前的题目容易让人想成i是ith鸡蛋,但是其实也可以是第一次,i-1是其后的鸡蛋.那么第一个鸡蛋扔后,可以坏也可以不坏.坏的话就是dp[i-1][h-1] + 1, h指的是坏在h层.那么只需要再用i-1个鸡蛋试试h-1层了.如果不坏的话则是dp[i-1][N-h] + 1. 但是我们还有想到,这两者的最大值才是我们要取的.所以dp[i][j] = min(1 + max(dp[i-1][h-1], dp[i-1][N-h])) 1<=h<=N, 初始是 dp[k][0] = 0, dp[1][n] = n.

* 13 L939 Minimum Area Rectangle
  > Given a set of points in the xy-plane, determine the minimum area of a rectangle formed from these points, with sides parallel to the x and y axes. If there isn't any rectangle, return 0.

  下边这种解法非常棒, 它是建立了一个set,这个set里的所有的点都是candidates,然后从arr里一个一个地找一个start的点,再看在candiates中能不能找到对角点能组成rectangle.而这里有个trick,就是组成rectangle的点的坐标是 [x1, y2], [x2, y1].这个trick是解决问题的关键点.

  同时,为了不重复找点,set里只存遍历过的点.
  ```
  def minAreaRect(self, points):
      seen = set()
      res = float('inf')
      for x1, y1 in points:
          for x2, y2 in seen:
              if (x1, y2) in seen and (x2, y1) in seen:
                  area = abs(x1 - x2) * abs(y1 - y2)
                  if area and area < res:
                      res = area
          seen.add((x1, y1))
      return res if res < float('inf') else 0
  ```

* 14 L354 俄罗斯套娃题
  > You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope. What is the maximum number of envelopes can you Russian doll? (put one inside other)

  本质就是维护一个单调递增的stack.而这个stack中的元素是可以被更改的
  ```
  import bisect
  class Solution(object):
      def maxEnvelopes(self, envelopes):
          if not envelopes:
              return 0
          envelopes.sort(key=lambda x:(x[0],-x[1]))
          h=[]
          for i,e in enumerate(envelopes,0):
              j=bisect.bisect_left(h,e[1])
              if j<len(h):
                  h[j]=e[1]
              else:
                  h.append(e[1])
          return len(h)
  ```

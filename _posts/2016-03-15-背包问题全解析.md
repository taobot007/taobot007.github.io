---
layout: post
title: 背包问题全解析
date: 2016-03-15
tag: Leetcode
---

背包问题(Knapsack problem)是经典DP算法问题.leetcode上从背包问题已经延伸出了许多题.我试图通过这篇博客给背包及相关问题来个全解析,从基础的01背包问题一直讲到将leetcode上的相关题型一网打尽.

## 01背包问题

我们先从01背包问题讲起. 问题是这样的:

>有N件物品和一个容量为V的背包。第i件物品的价值是c[i]，体积是v[i]。求解将哪些物品装入背包可使价值总和最大。

这里每件商品是独立的,即每件商品只能拿一次或者不拿(0或1,这就是01的由来).如果第一次遇到这种题型,大多数人的想法是DFS,即每种可能性都试一试,把最佳组合给"试出来".但是这样的话我们可以稍微算一算时间复杂度: 总共N种商品,每种商品都可以选或者不选,那么时间复杂度为$O(2^N)$.这样指数型的时间复杂度是不能接受的,我们必须找新的解法,这就是我要讲的DP解法.

01问题的DP解法是这样的:
>dp[i][k]: 前i(0<=i<=N)个物品放入容量为k的背包中所组合成的最大价值.注意这些物品的总体积不一定能达到k,而第i个物品也不一定要放入背包中.最终的结果为dp[N][V]
>
>转移方程: dp[i][k] = max(dp[i-1][k], dp[i-1][k-v[i]] + c[i]), 时间复杂度为$O(2^N)$.
>
>初始条件: 当V==0时,总价值为0.所以 dp[*][0] = 0.当物品为0时,总价值也为0,所以dp[0][*] = 0.

图示: 假如有4个物品,(体积,价值)为: （5，12），（4，3），（7，12），（2，3)

| 背包容量 | 0   |   1 |   2 |   3 |   4 |   5 |   6 |   7 |    8 |  9 |  10 |  11 |  12 | 13  |  14 | 15 |
| ------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 没有物品 | 0   |  0  |   0  |  0  |  0  | 0  |   0  |  0  |  0  |  0  | 0  |  0  |  0  |  0  |   0  |  0  |
| 物品1   | 0   |  0  |   0  |  0  |  0  | 12  | 12  |  12 |  12 | 12  |  12 | 12  |  12 | 12  |  12 | 12  |
| 物品2   | 0   |  0  |   0  |  0  |  3  | 12  | 12  |  12 |  12 | 15  |  15 | 15  |  15 | 15  |  15 | 15  |
| 物品3   | 0   |  0  |   0  |  0  |  3  | 12  | 12  |  12 |  12 | 15  |  15 | 15  |  24 | 24  |  24 | 24  |
| 物品4   | 0   |  0  |   3  |  3  |  3  | 12  | 12  |  15 |  15 | 15  |  15 | 18  |  24 | 24  |  27 | 27  |

请记住这张表.所有的背包问题最终都归于这么一张表,理解它可以让你就理解了背包问题.最终答案为dp[4][15] = 27. 01背包问题圆满解决.上边的解法还可以进行空间优化.因为转移方程为dp[i][k] = max(dp[i-1][k], dp[i-1][k-v[i]] + c[i]), 即第i行只跟第i-1行相关,所以我们可以使用滚动数组方法只记录一行,每次更新的时候从已经计算好的列值中计算当前列的值.

## 完全背包问题

>有N种物品和一个容量为V的背包。第i种物品的价值是c[i]，体积是v[i]。每种物品个数不限,求解将哪些物品装入背包可使价值总和最大。

这题可以由01背包问题的解法做延伸.方案1,把第i种物品的每一件都当做全新的一个物品种类,那么第i种物品就可以扩展成V/v[i]件物品,完全背包问题转换为01背包问题.方案2,重新考察dp[i][k]的转移方程.

>转移方程: dp[i][k] = max(dp[i-1][k], dp[i-1][k-q * v[i]] + q * c[i]),  1 <= q <= N/v[i]

因为 max(dp[i-1][k-q * v[i]] + q * c[i]), 1 <= q <= N/v[i] 的含义为放入[1, N/v[i]]个i物品组合的最大价值,所以也就等于 dp[i][k-v[i]] + c[i].上边的转移方程就简化变成:

> dp[i][k] = max(dp[i-1][k], dp[i][k-v[i]] + c[i])

最终结果为dp[N][V].我们也可以像01问题那样对算法的空间复杂度使用滚动数组进行优化.下面我们来看看leetcode中的与背包问题类似的题.

## Leetcode中的那些题:


#### [Leetcode 322. Coin Change](https://leetcode.com/problems/coin-change/)

>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

题目大意: 给你一些不同币值的硬币，问你最少需要多少个硬币才能组成amount，假设每种硬币有无穷多个。

经典的背包问题问的是这样取得**最大**值,而这题问的是所需硬币的**最小**个数.所以我们初始化的时候可以设置成maxint.这题中每种硬币的数量不限,所以跟完全背包问题更为接近,硬币的面值类比与背包问题中的体积,个数类比于价值.解法为:

>dp[i][k]: 组成k amount所需硬币的最小值. 最终结果为,当dp[N][K]为maxint时返回-1,否则返回dp[N][K]
>
>转移方程: dp[i][k] = min(dp[i-1][k], dp[i][k - coins[i]] + 1)
>
>初始化: dp[\*][\*] = maxint, dp[\*][0] = 0, dp[0][\*] = maxint
